name: C++ CI (Build, Test, Coverage)

on:
  push:
    branches: [ main, master, dev ] # Run on push to main or master branch
  pull_request:
    branches: [ main, master, dev ] # Run on pull requests to main or master

env:
  BUILD_TYPE: Release # Or Debug, RelWithDebInfo
  BUILD_DIR: ${{ github.workspace }}/build_ci
  # Path for JUnit XML test results
  TEST_RESULTS_DIR: ${{ github.workspace }}/test-results

jobs:
  build-test-coverage:
    runs-on: ubuntu-latest # Use a Linux runner for GCC/Clang and lcov

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up C++ Build Environment
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake lcov gcovr

    - name: Configure CMake
      run: |
        ls -la # List files to ensure we're in the right directory
        echo "Configuring CMake in directory: ${{ env.BUILD_DIR }}"
        mkdir -p ${{ env.BUILD_DIR }}
        cmake -S . -B ${{ env.BUILD_DIR }} \
              -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
              -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
              -DCOVERAGE=ON # Add a flag to enable coverage build flags in CMakeLists.txt

    - name: Build Project (including tests)
      run: cmake --build ${{ env.BUILD_DIR }} --config ${{ env.BUILD_TYPE }} --parallel $(nproc)

    - name: Create Test Results Directory
      run: mkdir -p ${{ env.TEST_RESULTS_DIR }}

    - name: Run Unit Tests and Generate JUnit XML
      # CTest can generate JUnit XML directly. This is crucial for reporting actions.
      # The '--output-on-failure' is still useful for immediate log review.
      # '--output-junit <file>' specifies the output XML file.
      run: |
        ctest --test-dir ${{ env.BUILD_DIR }} \
              --output-on-failure \
              --output-junit ${{ env.TEST_RESULTS_DIR }}/test-results.xml
      continue-on-error: true # Allow workflow to continue even if tests fail, so reports can be generated

    - name: Publish Test Results (Green/Amber Dot)
      uses: dorny/test-reporter@v1 
      if: always()
      with:
        name: Unit Test Results 
        path: ${{ env.TEST_RESULTS_DIR }}/*.xml
        reporter: junit 
        fail-on-error: true 
        summary: true 

    - name: Generate Code Coverage Report
      # Adjust paths based on where your source and build directories are
      run: |
        # Clean previous coverage data (important for sequential runs)
        lcov --directory ${{ env.BUILD_DIR }} --zerocounters

        # Run tests again to generate fresh .gcda files
        # It's important to run tests *after* zerocounters and *before* capture
        ctest --test-dir ${{ env.BUILD_DIR }}

        # Capture coverage data
        lcov --capture --directory ${{ env.BUILD_DIR }} --output-file coverage.info

        # Filter out system headers and third-party libraries (customize as needed)
        # Assuming your main application source is in `src/` and tests are in `test/`
        lcov --remove coverage.info "/usr/*" --output-file coverage_filtered.info
        lcov --remove coverage_filtered.info "*/_deps/*" --output-file coverage_filtered.info # For FetchContent
        lcov --remove coverage_filtered.info "*/test/*" --output-file coverage_filtered.info # Exclude test files themselves
        
        # Generate an HTML report
        genhtml coverage_filtered.info --output-directory ${{ env.BUILD_DIR }}/html_coverage

    - name: Display Coverage Summary
      # Use gcovr to get a textual summary directly in the workflow log and job summary
      # Make sure gcovr is installed (added in "Set up C++ Build Environment")
      run: |
        gcovr --lcov -o coverage_gcovr.info ${{ env.BUILD_DIR }} # Generate gcovr specific info
        echo "## Code Coverage Summary" >> $GITHUB_STEP_SUMMARY
        gcovr --summary --print-summary --exclude-unreachable-lines --filter "src/" >> $GITHUB_STEP_SUMMARY
        # You can also generate a more detailed text report if desired:
        # gcovr --relative-path ${{ github.workspace }} --filter "src/" --exclude-directories "test/" --html-details -o coverage_details.html
        # echo "See detailed coverage: ${{ env.BUILD_DIR }}/coverage_details.html" >> $GITHUB_STEP_SUMMARY
      # This step needs to run after coverage generation
      if: always()

    - name: Upload HTML Coverage Report as Artifact (Optional)
      uses: actions/upload-artifact@v4
      with:
        name: html-coverage-report
        path: ${{ env.BUILD_DIR }}/html_coverage
        retention-days: 5